process.on("uncaughtException", (error) => {
  console.log("caught unhandled error: " + error);
});
import { createServer, IncomingMessage, ServerResponse } from "http";
import { createHash } from "crypto";
import { readdirSync, readFileSync, lstatSync } from "fs";
import EventEmitter from "events";
import path from "path";
const PORT = 80;
IncomingMessage.prototype.json = function () {
  return new Promise((resolve, reject) => {
    this.on("data", (data) => {
      try {
        data = JSON.parse(data.toString());
        resolve(data);
      } catch (e) {
        reject(e);
      }
    });
  });
};
ServerResponse.prototype.json = function (json, status = 200) {
  this.writeHead(status, { "Content-Type": "application/json" });
  this.end(JSON.stringify(json));
};
const views =
  (function cacheViews(dir) {
    try {
      return readdirSync(dir).reduce((views, file) => {
        file = path.join(dir, file).replaceAll("\\", "/");
        if (lstatSync(file).isDirectory())
          return { ...views, ...cacheViews(file) };
        const url = file.replace(/^views\//, "/");
        const content = readFileSync(file);
        views[url] = content;
        if (url.endsWith("index.html")) {
          if (url == "/index.html") views["/"] = content;
          else views[url.replace(/\/index\.html$/, "")] = content;
        }
        return views;
      }, {});
    } catch (e) {}
  })("views") ?? {};
const routes = [];
createServer((req, res) => {
  routes.USE?.forEach(({ url: callback }) => callback(req, res));
  res.setHeader("Access-Control-Allow-Origin", "*");
  const requestPaths = req.url.replace(/\?.+$/, "").split("/").slice(1);
  for (const { paths, callback } of routes[req.method] || []) {
    const args = [];
    if (
      !(
        paths[paths.length - 1] != "*" && paths.length != requestPaths.length
      ) &&
      paths.reduce((bool, path, i) => {
        if (!bool) return false;
        if (path == "$") {
          args.push(requestPaths[i]);
          return true;
        }
        if (path == "*" || path == requestPaths[i]) return true;
        return false;
      }, true)
    ) {
      callback({ req, res, args });
      return;
    }
  }
  const ws = routes.WS?.find(({ url }) => url == req.url);
  if (ws) {
    const body = STATUS_CODES[426];
    res.writeHead(426, {
      "Content-Length": body.length,
      "Content-Type": "text/plain",
    });
    res.end(body);
    return;
  }
  const content = views[req.url.replace(/\?.+$/, "")];
  if (content) {
    if (req.url.endsWith(".js")) {
      res.setHeader("Content-Type", "text/javascript");
    }
    res.writeHead(200);
    res.end(content);
    return;
  }
  res.end(`Cannot ${req.method} ${req.url}`);
})
  .listen(PORT, () => console.log(`server listening on :${PORT}`))
  .on("upgrade", (req, socket) => {
    const { callback } = routes.WS.find(({ url }) => url == req.url);
    socket.write(
      "HTTP/1.1 101 Switching Protocols\r\n" +
        "Upgrade: websocket\r\n" +
        "Connection: Upgrade\r\n" +
        `Sec-WebSocket-Accept: ${createHash("sha1")
          .update(
            req.headers["sec-websocket-key"] +
              "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
          )
          .digest("base64")}\r\n\r\n`
    );
    const customSocket = new EventEmitter();
    socket.on("data", (data) => {
      if (data[0] == 0x88) {
        customSocket.emit("close");
        return;
      }
      const xor = data.slice(2, 6);
      data = data.slice(6).map((byte, i) => byte ^ xor[i % 4]);
      customSocket.emit("data", data);
    });
    customSocket.write = (text) => {
      socket.write(Buffer.from([0x81, text.length, ...Buffer.from(text)]));
    };
    callback(customSocket);
  });
export default new Proxy(routes, {
  get(routes, method) {
    method = method.toUpperCase();
    routes[method] ??= [];
    return (url, callback) => {
      routes[method].push({
        url,
        paths: url.split("/").slice(1),
        callback,
      });
    };
  },
});
